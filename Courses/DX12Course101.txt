This course has a set of projects that will help you program in DirectX.  This is a very long road but rewarding.

This course uses materials that are put together my different people from the industry. I would not expect 
them to be Christian, but probably have some Christian values because our culture was strongly influenced 
by Christianity. I avoid materials that use bad language or crude commentary.
I will include verses between lessons so we don't loose sight of what really matters, a 
relationship with God and remembering that this life is short and eternity is long. Lying, steeling, coveting,
lusting after someone who is not your spouse (which is adultery in your heart), taking Gods name in vain, 
hating your brother (which is murder in your heart), worshiping another God; are all wrong (sins). 
Have you sinned in your life? You have heard of a "debt to society" for crimes; well sins are giant debts. 
If we are treated justly, morally right or fair, we are condemned. After a lifetime we have a huge dept and 
no way to pay. If God ignored our wrong-doings, our sins, justice would not be His nature. 
However, God is not only just but loving and merciful and that is what the cross if all about. 

Hebrews 11:6 - and without faith it is impossible to please God, for whoever would draw near to God must 
	believe that he exists and that he rewards those who seek him.
 


This course uses the book "3D Game Programming with DirectX12"; however, the book is not used until the end
because this assumes there are many areas of c++, and overall programming, that the student is not 
familiar with and needs help. By the end of this course, many c++ concepts will be reviewed and then
the book is used from that point on. The program built in this course is not exactly like the book sample
on purpose. This is to force the student to understand and not copy/paste their way through the course.

Complete each project as listed below. Some projects are lessons.  The lesson may have its own sub-projects. 
If you have already done one of the projects, just re-read them but you don't have to do the work.
If you have already done them, but don't remember them; you need to do them again.



-----------------------------------------
Projects
Place all work in the following directory structure: c:/modules/YourName/DX12Course101/ProjectNameHere/...

After several lessons, we will start to use github, an online place to put your code, so the directory will not change after that is started.



This course takes you to creating a box on the screen using DirectX.
This course is a combination of C++ lessons and DirectX lesson.

At the bottom of this document is APPENDIX A. 
APPENDIX A is a high level list of DirectX objects and API calls that we will be building/working toward.
After each DirectX lesson, you can see how each lesson's components fix into the larger application.

-------------------------------------------



Book - At some point in the course you will start reading the book "3D Game Programming with DirectX 12".
	It might be a good idea to read chapter 4 and then start these lessons; however, if you are not
	skilled in c++ you may need to wait and go though the lessons first. This is because these
	lessons go beyond the book and contain c++ lessons along the way.






Proj_CppSimpleWindowsApp
	Finish lesson CppSimpleWindowsApp
	
	
Verse for the day: Matthew 5:3 - Blessed are the poor in spirit, for theirs is the kingdom of heaven.
	
	
Proj_CppPointers 
	Finish lesson CppPointers

Proj_CppPointerToPointer 	
	Finish lesson CppPointerToPointer

Proj_CppPreprocessor
	Finish lesson CppPreprocessor

Proj_CppVector
	Finish lesson CppVector

Proj_CppFactory
	Finish lesson CppFactory

Proj_IDXGIFactory4
	Complete the following 
		As always, create a project directory using the directory structure listed at the top of this course.
		Copy the application you created for the CppSimpleWindowsApp project to the new directory for this project.
			For example, for me I will copy directory DavantAppABC 
				FROM Folder: C:\modules\Davant\DX12Course101\Proj_CppSimpleWindowsApp\
				TO Folder:   C:\modules\Davant\DX12Course101\Proj_IDXGIFactory4\
		Rename the cpp file that contains "main" to Proj_IDXGIFactory4.cpp.
		Use lesson DX12_IDXGIFactory4 as a guide to add the direct x factory to your application.
		Compile and run the application. 

Proj_CppTypeDef
	Finish lesson CppTypeDef
	
Proj_ID3D12Device
	Complete the following 
		As always, create a project directory using the directory structure listed at the top of this course.
		Copy the application you created for the Proj_IDXGIFactory4 project to the new directory for this project.
			For example, for me I will copy directory DavantAppABC 
				FROM Folder:  C:\modules\Davant\DX12Course101\Proj_IDXGIFactory4\
				TO Folder:    C:\modules\Davant\DX12Course101\Proj_ID3D12Device\
		Rename the cpp file that contains "main" to Proj_ID3D12Device.cpp.
		Compile and run the application.
		Using lesson DX12_ID3D12Device create the interface to the GPU adaptor.


Pro_CppConst
	Finish lesson CppConst 


Pro_CppOperatorOverloading
	Finish lesson CppOperatorOverloading.

Pro_CppAssert
	Finish lesson CppAssert

Proj_CppTemplates
	Complete Lesson CppTemplates

Proj_CppInheritance
	Finish lesson CppInheritance

Proj_CppPolymorphism
	Finish lesson CppPolymorphism 


Proj_COM_Review
	Read lesson DX12_COM.
	There is no program for this lesson.


Proj_ComAndAdaptorToCreateID3D12Device
	Complete the following 
		As always, create a project directory using the directory structure listed at the top of this course.
		Copy the application you created for the Proj_ID3D12Device project to the new directory for this project.
			For example, for me I will copy directory DavantAppABC 
				FROM Folder:  C:\modules\Davant\DX12Course101\Proj_ID3D12Device\
				TO Folder:    C:\modules\Davant\DX12Course101\Proj_ComAndAdaptorToCreateID3D12Device\
		Rename the cpp file that contains "main" to Proj_ComAndAdaptorToCreateID3D12Device.cpp.
		Compile and run the application.
		Using lesson DX12_ComAndAdaptorToCreateID3D12Device update the code.
		Compile and run the application.


Proj_CppMap
	Finish lesson CppMap


Proj_CppVector2
	Finish lesson CppVector2

Proj_CppAuto
	Finish lesson CppAuto

Proj_CppProjectFilesAndCodeOrganization
	Finish lesson CppProjectFilesAndCodeOrganization 

Proj_CppVisualStudioOutputDebugInfo
	Finish lesson CppVisualStudioOutputDebugInfo
	

Proj_AddOutputDebugString
	Complete the following 
		As always, create a project directory using the directory structure listed at the top of this course.
		Copy the application you created for the Proj_ComAndAdaptorToCreateID3D12Device project to the new directory for this project.
			For example, for me I will copy directory DavantAppABC 
				FROM Folder:  C:\modules\Davant\DX12Course101\Proj_ComAndAdaptorToCreateID3D12Device\
				TO Folder:    C:\modules\Davant\DX12Course101\Proj_AddOutputDebugString\
		Rename the cpp file that contains "main" to Proj_AddOutputDebugString.cpp.
		Compile and run the application.
		Using lesson DX12_AddOutputDebugString, update the code.
		Compile and run the application.


Proj_CppWindowsLoop
	Complete the following 
		As always, create a project directory using the directory structure listed at the top of this course.
		Copy the application you created for the CppSimpleWindowsApp project to the new directory for this project.
			For example, for me I will copy directory DavantAppABC 
				FROM Folder: C:\modules\Davant\DX12Course101\Proj_CppSimpleWindowsApp\
				TO Folder:   C:\modules\Davant\DX12Course101\Proj_CppWindowsLoop\
		Rename the cpp file that contains "main" to Proj_CppWindowsLoop.cpp.
		Complete lesson CppWindowsLoop 


Proj_CppStaticVariableInAClass
	Complete lesson CppStaticVariableInAClass.


Proj_Github_Setup
	Complete the Github_Setup lesson.

Proj_Github_UpdateCloudWithChanges
	Complete the Github_UpdateCloudWithChanges lesson.

Proj_Github_GetARepository
	Create a lesson on how to get an existing repository on a new computer.

Proj_Github_Pull
	Complete the Github_Pull lesson. This actually does not have any steps, just covers the difference between "Clone" and "Push".


	
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------

Setup Github!!!
Moving forward, we will use github to store your code so the project name will not match the directory anymore.
We will use the same directory for the remaining Dx12 lessons.

In the github app, create a new repository named "Dx12CourseApp" in the C:\modules\your name\DX12Course101\

In the previous Dx12 lesson, you have code in the (C:\modules\you name\DX12Course101\Proj_AddOutputDebugString\YournameAppABC\) directory.
Copy all the files from that directory to the github directory you just created.
	For example I copied: 
		Directory DavantAppABC
		File DavantAppABC.sln
	If you see the ".vs" directory, you don't have to copy it. It will get generated the next time you compile in Visual Studio.
		


Now go to the github application and you should see all the files.
Commit to the local repository, give it a summary like "initial load".
Now publish to the github cloud. 

Open the solution.
Rename the file that has WinMain from "Proj_AddOutputDebugString.cpp" to "Proj_Dx12App.cpp".

Go back into github and you should see this change.
Notice it has a negative red [-] next to "Proj_AddOutputDebugString.cpp" because it does not exist anymore.
Notice is has a plus green [+] next to the file named "Proj_Dx12App.cpp" because it is a new one. Github does not know you changed the
	name, it only knows that one is gone and another has appreared.

There are several Visual Studio files that keep logs and other data that are not needed in github. They take up a large amound of memory
	so we want to set github to ignore them.
In github, look for a file that has an extension of ".ipch". It is usually a long filename. Right click on it and select "Ignore all .ipch files".
	The file still exists but will not be shown in github.
	Do the same for extension ".tlog".
	Do the same for extension ".log".

Commit your code and then publish to the cloud. You can add the summery name "clean up things" if you wish.

You are now ready to move on to the next set of projects.

------------------------------------------------------------------------------
------------------------------------------------------------------------------



Proj_DX12AddWindowsMessageLoop - NO NEW DIRECTORY - DO NOT create this directory for this project!	
	You will use your new directory that is using github.
	Open the visual studio solution.  It is located in the directory you just created for the github repository. 
		For example, for me it is: C:\modules\Davant\DX12Course101\Dx12CourseApp\

	This project will add in the windows loop code we did in project Proj_CppWindowsLoop.  

	This means the program from this lesson will have a windows message loop and the DirectX components from the DX lessons we have so far.
	This lesson will start to use github to keep your code files.

	Complete lesson DX12_AddWindowsMessageLoop.
	
	Git Tag lesson
		Now that you have updated github, it is time to "TAG" your code. Tagging your code creates a "Point in Time" copy
		of your code. 
		Review the github lesson "Github_Tag", and use the tag "v1.001_DX12_AddWindowsMessageLoop" to tag your project.



Proj_DX12CommandQueue 
	Open the visual studio solution.  It is located in the directory you just created for the github repository. 
		For example, for me it is: C:\modules\Davant\DX12Course101\Dx12CourseApp\
	
	Complete lesson DX12_CommandQueue.
	
	Github - "Commit to Master", give it a nice summary name, and then "Push origin" which will push it to the github cloud.
	
	Git Tag lesson
		Now that you have updated github, it is time to "TAG" your code. Tagging your code creates a "Point in Time" copy
		of your code. 
		Review the github lesson "Github_Tag", and use the tag "v1.002_Proj_DX12CommandQueue" to tag your project.
		Using a browser, go to your online github repository and see if you see the new tag under "releases".


Proj_DX12CommandListAndCommandAllocator	
	Open the visual studio solution.  It is located in the directory you just created for the github repository. 
		For example, for me it is: C:\modules\Davant\DX12Course101\Dx12CourseApp\

	Complete lesson DX12CommandListAndCommandAllocator.
	
	Github - "Commit to Master", give it a nice summary name, and then "Push origin" which will push it to the github cloud.
	
	Git Tag lesson
		Now that you have updated github, it is time to "TAG" your code. Tagging your code creates a "Point in Time" copy
		of your code. 
		Review the github lesson "Github_Tag" if needed, and use the tag "v1.003_Proj_DX12CommandListAndCommandAllocator" 
		to tag your project.
		Using a browser, go to your online github repository and see if you see the new tag under "releases".
		
		
Proj_DX12SwapChain
	Open the visual studio solution.  
		For example, for me it is: C:\modules\Davant\DX12Course101\Dx12CourseApp\

	Complete lesson DX12_SwapChain.
	
	Github - "Commit to Master", give it a nice summary name, and then "Push origin" which will push it to the github cloud.
	
	Git Tag lesson
		Now that you have updated github, it is time to "TAG" your code. Tagging your code creates a "Point in Time" copy
		of your code. 
		Review the github lesson "Github_Tag" if needed, and use the tag "v1.004_Proj_DX12_SwapChain" 
		to tag your project.
		Using a browser, go to your online github repository and see if you see the new tag under "releases".

	
		

------------------------------------------------------------------------------
------------------------------------------------------------------------------
		
BOOK - Time to Read!
	OK, we have waited long enough and it's time to read the book!  
	The first few chapters, 1-3, cover math and geometry so I will not focus on those at this point.
	Read chapter 4 of the book "3D Game Programming with DirectX 12".
		
------------------------------------------------------------------------------
------------------------------------------------------------------------------
		
	
Proj_DX12_DXGI_SAMPLE_DESC	
	This lesson does not have any code changes unless you want to try different multisample count options.
	It is here to review section 4.1.8 in the book.

	
	
Proj_Chapter4
	Open the visual studio solution.  
		For example, for me it is: C:\modules\Davant\DX12Course101\Dx12CourseApp\

	From here on out, you will be using the book.  Use the book to finish the initialization of DirectX.
	There are a few things still to do. Like the other objects that are setup, create functions for each
	of the following components and member variables in your myDirectX class. 
	You do not need to re-do components that have already been done.
	
	The following components still need to be added and initialized.
	Remember the book uses ComPtr, but you should make your own.

		Done - Add a ID3D12Fence * property and initialize it with a function named	
			"HRESULT myDirectX::InitializeFence(void)".
			Take the popup "Success" message from the last placed used and add it to this function.	
			
			After your done call this new "InitializeFence" function from the "initialize" function.
			
			Remember to call release on this objects in the myDirectX destructor.
			
			Understanding fences is covered in Chapter 4 in several sections. Code is covered in 
			section 4.3.2.
				
		Done - Add 3 properties to hold the descriptor sizes. Something like the following. These 
			should be private and goes in myDirectX.
				UINT mRtvDescriptorSize = 0;
				UINT mDsvDescriptorSize = 0;
				UINT mCbvSrvUavDescriptorSize = 0;
			Initialized these 3 descriptor size properties by creating a function and call that 
			function from the "Initialize" function.
			
			Take the popup "Success" message from the last placed used and add it to this function.
			
			Descriptors are reviewed in Chapter 4.  Code is covered in 
			section 4.3.2.
			
		Done - Add "Render Target View Descriptor" and "Depth Stencil View Descriptor" Heaps.
			Remember the book uses ComPtr, but you should make your own. 
			These should be private and goes in myDirectX.
			
			ID3D12DescriptorHeap * mpRtvID3D12DescriptorHeap = nullptr;
			ID3D12DescriptorHeap * mpDsvID3D12DescriptorHeap = nullptr;

			Initialized these 2 descriptor heaps by creating a function named InitializeRtvAndDsvDescriptorHeaps
			and call that function in your "Initialize" function. 
			
			Take the popup "Success" message from the last placed used and add it to this function.

			Remember to call release on this objects in the myDirectX destructor.
			
			Descriptors are reviewed in Chapter 4.  Code is covered in 
			section 4.3.6.
		
		Done - Add an int that is used to track the current back buffer. It will change 
			from 0 to 1 and 1 to 0... back and fourth. The reason is that we have 2
			render targets in this program. One for the screen the user is seeing and
			one that we are drawing to; hence the "double buffering" term.
			The "back buffer" is the one we are drawing to. This variable will keep 
			track of which of the two render targets is the back buffer at the current
			moment.
			This is mentioned in section 4.3.6.  This should be private and goes in myDirectX.
			
			int mCurrBackBuffer = 0; // toggles between 0 and 1 in this application.
		
		Done - Add a CurrentBackBufferView(..) function like shown in 4.3.6.
			This function returns a D3D12_CPU_DESCRIPTOR_HANDLE. 
			The descriptors are on the GPU, kept in descriptor heaps. We need to get at 
			those descriptors. This is where the handle comes into play.
				From the book "Our application references descriptors through handles."
				
			The book uses a helper class named CD3DX12_CPU_DESCRIPTOR_HANDLE. This class
			makes is easier to get a descriptor handle from the GPU. This class exists 
			in a set of libraries provided by Microsoft. The file we need is "d3dx12.h".
			You can get this file on github at "https://github.com/Microsoft/DirectX-Graphics-Samples".
			Once you download and unzip this, you can search for the file.  Copy and place the "d3dx12.h" 
			file and put it in the same directory your other .h and .cpp files.
			The file is now in the windows directory, but Visual Studio does not know about it.
			Add the file to the Visual Studio project by right clicking on header folder in Visual Studio,
			select "add"->"existing item", then select the file.
			Now it is a part of your Visual Studio project. 
			
			Now I know what your thinking, when I add a header file I also have to add the binary library
			file to my project as well. Well actually, this header has all the code in it so 
			there is no library file. Every class and function are in-lined; meaning the real code of the
			declarations, which are the definitions, are in the same header file.
			
			Now you can code without any errors:
				#include "d3dx12.h"
			
			Now you can add the code from the book. Here is what my code looks like.
			
				D3D12_CPU_DESCRIPTOR_HANDLE myDirectX::CurrentBackBufferView() const
				{
					return CD3DX12_CPU_DESCRIPTOR_HANDLE(
						mpRtvID3D12DescriptorHeap->GetCPUDescriptorHandleForHeapStart(),
						mCurrBackBuffer,
						mRtvDescriptorSize);
				}
			
			This code says, hay GPU... here is a descriptor heap, give me a "CPU Handle" to one of the
			descriptors in the heap!  Notice we also give it the size of each descriptor so the GPU
			knows how large each element is in the heap.
			First parameter is the start of the descriptor heap.
			Second parameter is the element number in the heap we want; either 0 or 1 in our case because
				we only have 2 elements at the moment (one for front and one for back buffer views)
			Third is the size of each element in the heap.
		
		
		
		Done - Add a DepthStencilView function like shown in 4.3.6.
			This function, like the "CurrentBackBufferView" function, is just a simple "get".
			Unlike the "CurrentBackBufferView", there is only one element in the heap so there is 
			no need to determine the "current" back buffer or anything else. We simply return
			the first element in the heap.
			
			Here is what my code looks like.
				D3D12_CPU_DESCRIPTOR_HANDLE myDirectX::DepthStencilView() const
				{
					return mpDsvID3D12DescriptorHeap->GetCPUDescriptorHandleForHeapStart();
				}
				
		Done - Create a ID3D12Resource pointer array to hold the back buffer descriptors/views.			
								
			Here is what my code looks like. This should be private and goes in myDirectX.
				ID3D12Resource * mpSwapChainBufferViewList[2];
				
			In the destructor of myDirectX, call release on both of these.
				for (int i = 0; i < 2; i++)
				{
					if (mpSwapChainBufferViewList[i] != nullptr)
					{
						mpSwapChainBufferViewList[i]->Release();
					}
				}
		
		Done - Create a ID3D12Resource pointer to hold the depth stencil on the GPU. Only one of 
			these is needed. This way we don't have to as the swap chain for this all the time.
				ID3D12Resource * mpDepthStencilBufferView;

			In the destructor of myDirectX, call release on this.

				if (mpDepthStencilBufferView != nullptr)
				{
					mpDepthStencilBufferView->Release();
				}
				
				
				
		Done - Create a function that will make sure there are no more commands on the GPU command queue.
			We will call this function "FlushCommandQueue()".

			Done - Create the function declaration and empty definition in the myDirectX class.
				void FlushCommandQueue();
			
			To do this operation, we will use the "Fence" we initialized earlier.
			In the book, section 4.2.2, fences and why we need them are covered. Review this section again.
			
			A fence needs an int that you increment.  We will use a large integer number, UINT64, so we won't 
			run out	of numbers.  How it works is as follows.
				- Increment the integer
				- Add a fence command to the command queue, giving it your newly incremented integer value.
					The function on the command queue that does this is named "Signal", because we are 
					asking it to signal us when it reaches our fence.
					Note: 	Like all things added to the command queue, it will be put at the end of the list of 
							commands. So, if we get the signal then we know it has completed all the other
							commands in the command queue because it has reached out fence integer value.
				- Check the fence number on the GPU and if it is less than our new fence number then we will
					just wait for a signal. 
							
			Done - We will need this large int property. Create the int variable as a property of the myDirectX class.
				UINT64 mCurrentFence = 0;

			Done - In the FlushCommandQueue function that you just created, the first thing we want to do is 
				increment the fence integer so we know for sure it is larger than any previous fence value.
				
				void myDirectX::FlushCommandQueue()
				{
					mCurrentFence++;
				
				}
				
				
			Done - Next, add the fence code. Here is my complete FlushCommandQueue function. 
				Read the comments very carefully.
			
				void myDirectX::FlushCommandQueue()
				{
					// Advance the fence number
					mCurrentFence++;

					// Give the fence, with the new number, to the command queue.
					mpID3D12CommandQueue->Signal(mpID3D12Fence, mCurrentFence);

					// We just added a command to the command queue.
					// When the GPU runs this command, it will update the mpID3D12Fence with the new number.

					// Check the number in the fence, maybe it already set it!  Probably not, but we will check.
					if (mpID3D12Fence->GetCompletedValue() < mCurrentFence)
					{
						// The signal command has not been run yet... so wait for the signal.

						HANDLE eventHandle = CreateEventEx(nullptr, false, false, EVENT_ALL_ACCESS);

						// Fire event when GPU hits current fence.  
						HRESULT hr = mpID3D12Fence->SetEventOnCompletion(mCurrentFence, eventHandle);

						// Wait until the GPU hits current fence event is fired.
						WaitForSingleObject(eventHandle, INFINITE);
						CloseHandle(eventHandle);

					}

				}
				
				
			
		ToDo - We need a reset everything that is related to the screen size if the user changes
			the screen size. For example, render targets are based on the screen size.
			
			Changing the screen size will change the size of the render targets and depth stencil 
			resources. 
			
			Previously we create a descriptor/view heap for the 2 render targets and one for the 
			depth stencil. We also created ID3D12Resource pointers so we would have an interface 
			to the views.
			However, we never actually created the descriptor/views on either heap. Meaning the heaps 
			on the GPU were allocated but never populated.  Also, our ID3D12Resource pointers have 
			never been set. Obviously they can't be set until the views are created.
			
			This is the perfect place to do this. After the screen is resized by the user, the swap
			chain can be reset, the descriptor/views can be created on the heaps and we can create
			our ID3D12Resource pointer interface to the views.
			
			
			We will create an "OnResize()" function for the myDirectX class. This function can be called
			any time the user changes the screen size. It basically will reset the swap chain back
			buffers because if the screen size changes then the back buffer sizes need to change.
			
			Done - Create the function declaration and empty definition in the myDirectX class.
				void OnResize();
			
						
			
			Done - In the definition of the OnResize() function, check if the device, swap chain and
				allocator pointers are null. These should not be null so if they are, then return 
				without doing anything. This is making our code safer.
				
				void myDirectX::OnResize()
				{
					if (mpD3dDevice == nullptr)
					{
						return;
					}
					if (mpIDXGISwapChain == nullptr)
					{
						return;
					}
					if (mpID3D12CommandAllocator == nullptr)
					{
						return;
					}

					
			Done - Before we reset things, we should make sure the command queue is empty so we don't
				deleting a some resource the command queue might be using.
				Add to the OnResize() function a call to the FlushCommandQueue() function.
				In the void myDirectX::OnResize() function, add the following after the existing code
				from the previous steps.
				
					// Flush before changing any resources.
					FlushCommandQueue();
		
			
			
			Done - Now that the command queue is empty, let's reset the command list.  When we reset it
				we will give it the command allocator.
				In the void myDirectX::OnResize() function, add the following after the existing code
				from the previous steps.
				
					// When you reset a command list you give it a command allocator.
					mpID3D12GraphicsCommandList->Reset(mpID3D12CommandAllocator, nullptr);

					
		
			Done - We need to release the ID3D12Resource interface we use to work with the 
				descriptors/views, we have 2.  We also want to release the depth stencil buffer 
				descriptor/view interface as well.
				Remember, these are interfaces to descriptors/views on the descriptor heap, not the 
					actual descriptors/views on the descriptor heap.

				In the void myDirectX::OnResize() function, add the following after the existing code
				from the previous steps.

					// Release the previous resources we will be recreating.
					for (int i = 0; i < 2; ++i)
					{
						mpSwapChainBufferViewList[i]->Release();

					}

					mpDepthStencilBufferView->Release();

			
			Done - Now that we have reset and released resources, we can reset the swap chain and give
				it the new render target height and width which we get from the screen size of our 
				window.
				We will use the 2 member variables mRenderTargetWidth and mRenderTargetHeight and
				also set the format to DXGI_FORMAT_R8G8B8A8_UNORM as we have done before.
				We also set the number to 2 for the front and back buffers.
				
				In the void myDirectX::OnResize() function, add the following after the existing code
				from the previous steps.
				
					// Resize the swap chain.
					HRESULT hr = mpIDXGISwapChain->ResizeBuffers(
						2, // front and back buffer
						mRenderTargetWidth, mRenderTargetHeight,
						DXGI_FORMAT_R8G8B8A8_UNORM,
						DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH);

				
			Done - One simple thing we need to do is reset our variable that tracks the current back buffer.
				In the void myDirectX::OnResize() function, add the following after the existing code
				from the previous steps.
			
				// Reset the int that tracks the current back buffer.
				mCurrBackBuffer = 0;

			Done - Above we have released our swap chain buffer view interfaces. 
				We also had the swap chain create front and back buffers and depth stencil buffer for us.
				
				Because we released our view interfaces we need to re-create them.
				The descriptor/views are saved on the GPU heap we created at initialization.
				The GPU Heap just holds data so we can re-use it, just copy new data to it.
				We also need to create our ID3D12Resource interfaces, in c++, to those views on the GPU heap 
				so we can work with them.
				
				First we will get a CPU descriptor handle to the GPU heap. This "handle" is basically an 
				address to the heap on the GPU. We need this so we can update the GPU heap.
				
				Next we will create the render target views the GPU heap, meaning copy them there, and get 
				our resource handle to those render target views. We will use a for loop that loops 2 times
				for the front and back buffer.
				
				// First, CPU descriptor handle
				CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHeapHandle(mpRtvID3D12DescriptorHeap->GetCPUDescriptorHandleForHeapStart());
				
				// Next, update the GPU heap and set our resource pointer to the views on the GPU heap.
				for (UINT i = 0; i < 2; i++)
				{
					mpIDXGISwapChain->GetBuffer(i, IID_PPV_ARGS(&mpSwapChainBufferViewList[i]));

					mpD3dDevice->CreateRenderTargetView(mpSwapChainBufferViewList[i], nullptr, rtvHeapHandle);
					rtvHeapHandle.Offset(1, mRtvDescriptorSize);
				}
				
				
			ToDo - Now for the Depth Stencil buffer.
				This is created differently than the front and back buffers. Both the front and back buffers were allocated/created	for us by the swap chain. All we had to do is create the descriptors\views on the 
				descriptor heap and also set 2 c++ resource interfaces objects to them.
				
				For the Depth Stencil buffer, we have to create the actual resource on the GPU ourselves.
				This is done by filling out the DirectX struct of type D3D12_RESOURCE_DESC, and using it to ask the GPU
				to allocate the buffer(memory). We use the struct by passing it to a function call that DirectX provides 
				called "CreateCommittedResource(..)". This function is part of our DirectX GPU interface object.
				This struct and function are used to allocate many different kinds of recourses on the GPU, not just depth stencil buffers.
				
				// Depth Stencil resource.

				// Fill out a struct that will tell the GPU what we want it to create.
				D3D12_RESOURCE_DESC depthStencilDesc;
				depthStencilDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
				depthStencilDesc.Alignment = 0;
				depthStencilDesc.Width = mRenderTargetWidth;
				depthStencilDesc.Height = mRenderTargetHeight;
				depthStencilDesc.DepthOrArraySize = 1;
				depthStencilDesc.MipLevels = 1;
				depthStencilDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
				depthStencilDesc.SampleDesc.Count = 1; // book has m4xMsaaQuality ? 4 : 1;
				depthStencilDesc.SampleDesc.Quality = m4xMsaaQuality;
				depthStencilDesc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
				depthStencilDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;
				
				When we create the resource, what do we want its initial state set to? This will set the depth
				to 1.0, which means max distance. Any pixel will be closer than 1.0 so this is where we want 
				to start. The format is the same as listed in the depthStencilDesc struct and the "Stencil"
				has not been covered and won't be used yet so just set it to 0.
				D3D12_CLEAR_VALUE optClear;
				optClear.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
				optClear.DepthStencil.Depth = 1.0f;
				optClear.DepthStencil.Stencil = 0;
					

					
			
			WORKING HERE...

		
		ToDo - Add a function to get the actual current back buffer interface ID3D12Resource*.
			Name it something like "CurrentBackBuffer()".
			This will come from the swap chain because when we created the swap chain it automatically
			created two GPU resources.
			
			Here is what my code looks like. Notice it uses the same mCurrBackBuffer member variable
			we used previously in the "CurrentBackBufferView(..)" function.
		
				NOTE!! THIS code is in the myDirectX, just commented out.
		
	
	Github - "Commit to Master", give it a nice summary name, and then "Push origin" which will push it to the github cloud.
	
	Git Tag lesson
		Now that you have updated github, it is time to "TAG" your code. Tagging your code creates a "Point in Time" copy
		of your code. 
		Review the github lesson "Github_Tag" if needed, and use the tag "v1.005_Proj_Chapter4" 
		to tag your project.
		Using a browser, go to your online github repository and see if you see the new tag under "releases".



Done!  Wow, you did it!

Below is a high level list of the components you worked with in this course.


-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------

APPENDIX A - High Level Components and API Calls

DirectX Application

		Window's window and message loop
		IDXGIFactory4 * mpDxgiFactory;
		ID3D12Device * mpD3dDevice;
		IDXGIAdapter1 * mpHardwareAdapter;
		ID3D12CommandQueue * mpID3D12CommandQueue;
		ID3D12CommandAllocator * mpID3D12CommandAllocator;
		ID3D12GraphicsCommandList * mpID3D12GraphicsCommandList;
		IDXGISwapChain * name TBD;
		ID3D12Fence * name TBD;
		D3D12_VIEWPORT mScreenViewport;
		D3D12_RECT mScissorRect;
		ID3D12RootSignature  * name TBD;		
		ID3D12DescriptorHeap mCbvHeap; // Constant Buffer View Descriptor Heap
		ID3D12Resource mObjectCB; // Constant Buffer for World View Projection matrix
		ID3D12Resource  * name TBD; // MeshGeometry Vertex Buffer
		ID3D12Resource  * name TBD; // MeshGeometry Index Buffer		
		ID3DBlob mvsByteCode; // Vertex Shader Byte code
		ID3DBlob mpsByteCode; // Pixel Shader Byte Code		
		D3D12_INPUT_ELEMENT_DESC mInputLayout; 		
		ID3D12PipelineState mPSO; // Pipeline State objects		
		XMFLOAT4X4 mWorld; // Holds the World Space transformation.
		XMFLOAT4X4 mView; // Holds the View/Camera Space transformation.
		XMFLOAT4X4 mProj; // Holds the Projection transformation.
		
		ToDo - There are several other supporting properties that need to be added.
		
	On Each Draw Call - 60+ times a seconds do the following:
		Update()
			In this example, the box is the only object and it is always at position 0,0,0.
			Get the camera's position in world space.
			Calculate the World View Projection matrix for the box. 
			Update the GPU constant buffer resource that holds the world view projection for the
			object by using the interface object mObjectCB we created when the game started.

		Draw()
			
			Draw the box by calling the draw indicies function.
			
			Wait for the fence to be cleared.
			
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		










